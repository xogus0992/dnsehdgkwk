<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  
  <title>Pok√©mon Battle Final Fix</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Chakra+Petch:wght@700&family=Black+Han+Sans&display=swap');

    :root { 
      --hp-green: #00ff66; --hp-yellow: #ffcc00; --hp-red: #ff3300; 
    }

    html, body { 
      margin: 0; padding: 0; 
      width: 100%; height: 100%; 
      overflow: hidden; 
      background-color: #222; 
      font-family: 'Chakra Petch', sans-serif; 
      user-select: none; -webkit-user-select: none; 
      touch-action: none;
    }

    /* === Ïä§ÌÖåÏù¥ÏßÄ === */
    #game-stage {
      position: relative; width: 100%; 
      height: 100vh; height: 100dvh;
      
      background: 
        linear-gradient(to bottom, rgba(0,0,0,0.3), rgba(0,0,0,0.6)),
        url('https://cmsassets.rgpub.io/sanity/images/dsfx7636/news_live/fb316159b327db17fb08c333386e8bdfeff304fe-1731x1080.jpg');
      
      background-size: cover; background-position: center;
      overflow: hidden; 
      perspective: 1000px;
      transform: translateZ(0);
    }
    
    /* ... (CSS Ïä§ÌÉÄÏùºÏùÄ ÏÉùÎûµ. ÌååÏùº Í∏∏Ïù¥Î•º Ï§ÑÏù¥Îäî ÏöîÏ≤≠Ïóê Îî∞Îùº Ïã§Ï†ú CSS ÏΩîÎìúÎäî Í∑∏ÎåÄÎ°ú Ïú†ÏßÄÌïòÎêò, Ïó¨Í∏∞ÏÑúÎäî ÏÉùÎûµÌï©ÎãàÎã§.) ... */
    #speed-lines {
      position: absolute; inset: 0; pointer-events: none; z-index: 50;
      background: repeating-conic-gradient(from 0deg, transparent 0deg, transparent 10deg, rgba(255,255,255,0.1) 10deg, rgba(255,255,255,0.1) 12deg);
      opacity: 0; transition: opacity 0.2s; 
      mix-blend-mode: overlay;
    }

    #flash-overlay { position: absolute; inset: 0; background: white; opacity: 0; pointer-events: none; z-index: 9999; mix-blend-mode: overlay; transition: opacity 0.05s; }
    #game-stage::after { content: ''; position: absolute; inset: 0; background: radial-gradient(circle, transparent 50%, rgba(0,0,0,0.5) 100%); pointer-events: none; z-index: 40; }

    /* === Ï¥ù ÌåÄ Ï≤¥Î†•Î∞î (New Feature) === */
    #total-hp-container {
      position: absolute; top: 10px; left: 10px; right: 10px;
      display: flex; justify-content: space-between; gap: 50px;
      padding: 10px 20px;
      background: rgba(0, 0, 0, 0.7);
      border-radius: 10px;
      z-index: 100;
      box-shadow: 0 4px 15px rgba(0,0,0,0.5);
    }
    .total-hp-box {
      flex: 1; text-align: center;
    }
    .total-hp-title {
      font-size: 2.5vmin; color: #fff; font-weight: 900;
      font-family: 'Black Han Sans', sans-serif; margin-bottom: 5px;
    }
    .total-hp-bg {
      width: 100%; height: 2vmin; background: #444; border-radius: 5px;
      overflow: hidden; border: 2px solid #fff;
    }
    .total-hp-fill {
      height: 100%;
      background: linear-gradient(to right, #00f, var(--hp-green)); 
      transition: width 0.3s ease-out;
    }

    /* === Ïú†Îãõ Ïª®ÌÖåÏù¥ÎÑà === */
    .pokemon-unit {
      position: absolute; width: 22vmin; height: 22vmin;
      transform-style: preserve-3d; transition: opacity 0.5s;
      display: flex; flex-direction: column; align-items: center; justify-content: flex-end;
      overflow: visible !important;
      -webkit-backface-visibility: hidden; backface-visibility: hidden;
    }

    /* Î∞∞Ïπò Ï¢åÌëú: 3D Î∞∞Ïπò ÎäêÎÇåÏúºÎ°ú ÏàòÏ†ï */
    #enemy-unit-0 { top: 15%; right: 8%; z-index: 10; }
    #enemy-unit-1 { top: 38%; right: 8%; z-index: 20; }
    #enemy-unit-2 { top: 62%; right: 8%; z-index: 30; }
    #player-unit-0 { top: 15%; left: 8%; z-index: 10; }
    #player-unit-1 { top: 38%; left: 8%; z-index: 20; }
    #player-unit-2 { top: 62%; left: 8%; z-index: 30; }

    .poke-img-wrapper { position: relative; width: 100%; height: 100%; transform-style: preserve-3d; }
    
    .poke-img {
      width: auto; height: auto; max-width: 170%; max-height: 150%;
      object-fit: contain; filter: drop-shadow(0 1vmin 2vmin rgba(0,0,0,0.7));
      transform-origin: bottom center; transition: transform 0.3s, filter 0.3s;
      -webkit-transform: translateZ(0); transform: translateZ(0);
    }
    .shadow { position: absolute; bottom: 0; left: 50%; transform: translateX(-50%) rotateX(70deg); width: 80%; height: 20%; background: radial-gradient(rgba(0,0,0,0.8), transparent 70%); z-index: -1; }
    
    .poke-img.charging-aura {
        filter: drop-shadow(0 0 30px #ffffff) hue-rotate(90deg);
        animation: charge-pulse 0.4s infinite alternate;
    }
    @keyframes charge-pulse {
        from { transform: scale(1); opacity: 1; }
        to { transform: scale(1.05); opacity: 0.8; }
    }

    /* === Ï≤¥Î†•Î∞î (Í∞ÄÏãúÏÑ± ÌôïÎ≥¥) === */
    .mini-hud {
      position: absolute; 
      top: -40%; left: 50%; 
      width: 140%; padding: 4px;
      background: rgba(0, 0, 0, 0.85); 
      border: 2px solid #fff;
      border-radius: 8px; text-align: center; 
      z-index: 9999; 
      box-shadow: 0 4px 10px rgba(0,0,0,0.8);
      transform: translateX(-50%) translateZ(100px); -webkit-transform: translateX(-50%) translateZ(100px);
    }
    .hud-name { 
      font-size: 2.5vmin; color: #fff; font-weight: 900; 
      text-shadow: 1px 1px 0 #000; display:block; 
      white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
      font-family: 'Chakra Petch', sans-serif;
    }
    .hp-bg { width: 100%; height: 1.5vmin; background: #444; border-radius: 3px; overflow: hidden; border: 1px solid #888; margin-top: 2px; }
    .hp-fill { width: 100%; height: 100%; background: var(--hp-green); transition: width 0.3s ease-out; }

    /* === Ïä§ÌÇ¨ Ïù¥ÌéôÌä∏ (Í∞ïÌôî) === */
    .skill-beam { 
      position: absolute; transform-origin: center left; z-index: 1000; pointer-events: none; opacity: 0.9; 
      mix-blend-mode: screen; 
    }

    .beam-fire {
      height: 60px;
      background: linear-gradient(90deg, #fff 0%, #ffaa00 20%, #ff0000 100%);
      filter: blur(3px) contrast(1.5) drop-shadow(0 0 20px orange);
      clip-path: polygon(0% 30%, 100% 0%, 100% 100%, 0% 70%);
      animation: beamPulse 0.1s infinite;
    }
    .beam-water {
      height: 80px;
      background: repeating-linear-gradient(90deg, #00f, #0ff 20%, #00f 40%);
      background-size: 200% 100%; border: 3px solid white; box-shadow: 0 0 30px cyan;
      animation: waterFlow 0.3s infinite linear;
    }
    .beam-electric {
      height: 15px; background: white; box-shadow: 0 0 30px yellow;
      clip-path: polygon(0% 40%, 20% 0%, 40% 60%, 60% 10%, 80% 70%, 100% 50%, 100% 50%, 80% 100%, 60% 40%, 40% 90%, 20% 30%, 0% 60%);
      animation: thunderFlash 0.05s infinite;
    }
    .beam-psychic { /* ÏóºÎèôÎ†•/ÌååÎèô */
        height: 30px;
        background: radial-gradient(circle, #ff00ff, #800080);
        box-shadow: 0 0 20px #ff00ff;
        filter: blur(1px);
        animation: beamPulse 0.1s infinite;
    }
    
    @keyframes beamPulse { 0% { opacity: 0.8; transform: scaleY(1); } 100% { opacity: 1; transform: scaleY(1.3); } }
    @keyframes waterFlow { 0% { background-position: 0% 0%; } 100% { background-position: -100% 0%; } }
    @keyframes thunderFlash { 0% { opacity: 1; } 50% { opacity: 0.5; } 100% { opacity: 1; } }

    .projectile { position: absolute; width: 80px; height: 80px; z-index: 1000; background: radial-gradient(circle, #fff, transparent); filter: blur(2px); }
    .proj-wind { border-radius: 50%; box-shadow: 0 0 20px white; transform: scaleX(2); animation: windRotate 0.3s infinite linear; }
    .proj-earth { background: #5d4037; border-radius: 10px; box-shadow: 0 0 10px #3e2723; animation: rockSpin 0.5s infinite linear; }
    
    @keyframes windRotate { 0% { transform: rotate(0deg) scaleX(2); } 100% { transform: rotate(360deg) scaleX(2); } }
    @keyframes rockSpin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

    /* ÌÉÄÍ≤© Ïù¥ÌéôÌä∏ */
    .impact-burst { position: absolute; width: 200px; height: 200px; transform: translate(-50%, -50%); z-index: 1100; pointer-events: none; mix-blend-mode: screen; }
    .burst-fire { background: radial-gradient(circle, #fff, orange, red, transparent); animation: burst 0.4s forwards; }
    .burst-water { background: radial-gradient(circle, #fff, cyan, blue, transparent); animation: burst 0.4s forwards; }
    .burst-electric { background: radial-gradient(circle, #fff, yellow, transparent); animation: burst 0.2s forwards; }
    .burst-earth { background: radial-gradient(circle, #fff, #795548, transparent); animation: burst 0.4s forwards; }
    .burst-psychic { background: radial-gradient(circle, #fff, #ff00ff, transparent); animation: burst 0.4s forwards; }

    @keyframes burst { 0% { transform: translate(-50%, -50%) scale(0.2); opacity: 1; } 100% { transform: translate(-50%, -50%) scale(2.5); opacity: 0; } }

    /* ÏÜçÏÑ±Î≥Ñ ÌîºÍ≤© Ìö®Í≥º */
    .hit-fire { filter: sepia(1) saturate(7) hue-rotate(-50deg) drop-shadow(0 0 2vmin orange) brightness(1.2) !important; animation: burnShake 0.1s infinite !important; }
    .hit-water { filter: sepia(1) saturate(5) hue-rotate(180deg) drop-shadow(0 0 2vmin cyan) brightness(1.1) !important; transform: scale(0.95) !important; }
    .hit-electric { filter: sepia(1) saturate(10) hue-rotate(-10deg) drop-shadow(0 0 2vmin yellow) brightness(1.5) contrast(1.5) !important; animation: electricShock 0.08s infinite !important; }
    .hit-earth { filter: sepia(1) saturate(2) hue-rotate(-120deg) drop-shadow(0 0 1vmin #5d4037) brightness(0.8) !important; transform: translateY(5px) !important; }
    .hit-wind { filter: brightness(2) grayscale(1) drop-shadow(0 0 1vmin white) !important; opacity: 0.8; }
    .hit-psychic { filter: saturate(5) hue-rotate(270deg) drop-shadow(0 0 3vmin #ff00ff) !important; animation: pulse 0.1s 3; }

    @keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.5; } 100% { opacity: 1; } }
    @keyframes burnShake { 0% { transform: translateX(-2px); } 100% { transform: translateX(2px); } }
    @keyframes electricShock { 0% { opacity: 1; filter: brightness(2) sepia(1) hue-rotate(-10deg); } 50% { opacity: 0.6; } 100% { opacity: 1; } }

    /* Ïª®Ìä∏Î°§ Ìå®ÎÑê */
    #controls {
      position: absolute; bottom: 0; left: 0; width: 100%; 
      height: 15vh; height: 15dvh;
      background: linear-gradient(to top, rgba(0,0,0,1), rgba(0,0,0,0.7)); 
      border-top: 2px solid #ffd700;
      display: flex; justify-content: center; align-items: center; z-index: 200;
      padding-bottom: env(safe-area-inset-bottom);
    }
    #message-box { 
      color: #fff; font-size: 4.5vmin; font-weight: 900; 
      text-shadow: 2px 2px 0 #000; text-align: center; width: 90%; 
      font-family: 'Black Han Sans', sans-serif; letter-spacing: 1px;
    }

    .camera-shake { animation: shake 0.4s cubic-bezier(.36,.07,.19,.97) both; }
    @keyframes shake { 10%, 90% { transform: translate3d(-4px, 0, 0); } 20%, 80% { transform: translate3d(4px, 0, 0); } 30%, 50%, 70% { transform: translate3d(-6px, -3px, 0); } 40%, 60% { transform: translate3d(6px, 3px, 0); } }

    #loading { 
      position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
      background: #111; color: #ffd700; z-index: 9999; 
      display: flex; justify-content: center; align-items: center; 
      font-size: 5vmin; font-weight: bold; 
      transition: opacity 0.5s;
    }
  </style>
</head>
<body>

  <div id="loading">LOADING...</div>

  <div id="game-stage">
    <div id="speed-lines"></div>
    <div id="flash-overlay"></div>
    
    <div id="total-hp-container">
      <div class="total-hp-box">
        <div class="total-hp-title" style="color:#00ffcc;">ÏïÑÍµ∞ ÌåÄ HP</div>
        <div class="total-hp-bg"><div class="total-hp-fill" id="total-hp-player"></div></div>
      </div>
      <div class="total-hp-box">
        <div class="total-hp-title" style="color:#ff6666;">ÏÉÅÎåÄ ÌåÄ HP</div>
        <div class="total-hp-bg"><div class="total-hp-fill" id="total-hp-enemy"></div></div>
      </div>
    </div>
    
    <div id="enemy-unit-0" class="pokemon-unit"></div>
    <div id="enemy-unit-1" class="pokemon-unit"></div>
    <div id="enemy-unit-2" class="pokemon-unit"></div>
    <div id="player-unit-0" class="pokemon-unit"></div>
    <div id="player-unit-1" class="pokemon-unit"></div>
    <div id="player-unit-2" class="pokemon-unit"></div>
  </div>

  <div id="controls">
    <div id="message-box">READY...</div>
  </div>

  <script>
    const randomInt = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;
    const wait = (ms) => new Promise(resolve => setTimeout(resolve, ms));
    
    const POKEDEX_MAX = 151;
    
    // Í∏∞Ïà† Î™©Î°ù: Î∞îÎûå, Ìùô, Ï†ÑÍ∏∞, Î¨º, Î∂à, ÏóºÎèôÎ†•, ÌååÎèô, Í∑ºÏ†ë Í≥µÍ≤© Îì± ÏöîÏ≤≠ ÏÇ¨Ìï≠ Î∞òÏòÅ
    const SKILLS = [
      { type: 'fire', name: "üî• Î∂àÎåÄÎ¨∏Ïûê", mode: 'beam' },
      { type: 'water', name: "üíß ÌïòÏù¥ÎìúÎ°úÌéåÌîÑ", mode: 'beam' },
      { type: 'electric', name: "‚ö° 10ÎßåÎ≥ºÌä∏", mode: 'beam' },
      { type: 'psychic', name: "‚ú® ÏóºÎèôÎ†•", mode: 'beam' }, // ÏóºÎèôÎ†•
      { type: 'psychic', name: "üåÄ ÌååÎèôÌÉÑ", mode: 'beam' }, // ÌååÎèô
      { type: 'earth', name: "ü™® ÎåÄÏßÄÏùòÌûò", mode: 'projectile' }, // Ìùô
      { type: 'wind', name: "üå™Ô∏è ÏóêÏñ¥Ïä¨ÎûòÏãú", mode: 'projectile' }, // Î∞îÎûå
      { type: 'physical', name: "üëä Í∏∞Í∞ÄÏûÑÌå©Ìä∏", mode: 'melee' } // Í∑ºÏ†ë Í≥µÍ≤©
    ];

    class AnimeBattle {
      constructor() {
        this.playerTeam = [];
        this.enemyTeam = [];
        this.maxTotalHpPlayer = 0;
        this.maxTotalHpEnemy = 0;
        this.isGameOver = false;
        this.msgBox = document.getElementById('message-box');
        this.stage = document.getElementById('game-stage');
        this.speedLines = document.getElementById('speed-lines');
        this.init();
      }

      async init() {
        // ====================================================================
        // [ÌïµÏã¨ Ïó∞Í≤∞] Î°úÏª¨ Ïä§ÌÜ†Î¶¨ÏßÄÏóêÏÑú Lobby ÌååÏùºÏù¥ Ï†ÄÏû•Ìïú ÌåÄ Ï†ïÎ≥¥Î•º Î∂àÎü¨Ïò¥
        // ====================================================================
        const battleTeamJson = localStorage.getItem('battleTeam');
        let playerIds = [];

        if (battleTeamJson) {
            try {
                const teamData = JSON.parse(battleTeamJson);
                playerIds = teamData.map(p => p.id).filter(id => id && typeof id === 'number' && id > 0); 
            } catch (e) {
                console.error("Failed to parse battleTeam from localStorage:", e);
            }
        } 
        
        while (playerIds.length < 3) {
             playerIds.push(randomInt(1, POKEDEX_MAX));
        }
        
        // ÏÉÅÎåÄÎäî Î¨¥ÏûëÏúÑ 3ÎßàÎ¶¨ (ÌÖåÏä§Ìä∏ Î≤ÑÏ†Ñ)
        const enemyIds = Array.from({length: 3}, () => randomInt(1, POKEDEX_MAX));
        const allIds = [...playerIds.slice(0, 3), ...enemyIds];

        try {
          const promises = allIds.map(id => fetch(`https://pokeapi.co/api/v2/pokemon/${id}`).then(res => {
            if (!res.ok) throw new Error(`API fetch failed for ID: ${id}`);
            return res.json();
          }));
          const results = await Promise.all(promises);

          this.playerTeam = results.slice(0, 3).map((data, i) => this.parseData(data, true, i));
          this.enemyTeam = results.slice(3, 6).map((data, i) => this.parseData(data, false, i));

          this.calculateMaxTotalHp();

          this.renderUnit('player', this.playerTeam);
          this.renderUnit('enemy', this.enemyTeam);
          this.updateTotalHp();

          await wait(1500);
          document.getElementById('loading').style.opacity = 0;
          setTimeout(() => document.getElementById('loading').style.display = 'none', 500);
          
          this.battleLoop();

        } catch (e) { 
            console.error(e); 
            document.getElementById('loading').innerHTML = `ERROR: ${e.message}. RETRY...`;
            setTimeout(() => location.reload(), 2000);
        }
      }

      parseData(data, isPlayer, index) {
        let hp = data.stats[0].base_stat * 3 + 200;
        let name = data.name.toLowerCase().replace('-m','m').replace('-f','f').replace('mr-mime','mrmime').replace('farfetchd', 'farfetch‚Äôd').replace('nidoran-f', 'nidoranf').replace('nidoran-m', 'nidoranm');
        const h = data.height; 
        let scale = Math.min(Math.max(h < 5 ? 0.9 : h > 40 ? 1.35 : 1.0 + ((h-5)/60), 0.85), 1.4);
        
        // ÏÉÅÎåÄÎ•º Î∞îÎùºÎ≥¥Í≤å: ÌîåÎ†àÏù¥Ïñ¥Îäî Îí∑Î™®Ïäµ(xyani-back), ÏÉÅÎåÄÎäî ÏïûÎ™®Ïäµ(xyani)
        const spriteDir = isPlayer ? 'xyani-back' : 'xyani'; 
        let imgSrc = `https://play.pokemonshowdown.com/sprites/${spriteDir}/${name}.gif`;

        if (data.id > POKEDEX_MAX && !['deoxys', 'jirachi', 'hooh', 'lugia', 'celebi'].includes(name)) { 
             imgSrc = `https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/other/official-artwork/${data.id}.png`;
        }

        return {
          id: `${isPlayer?'player':'enemy'}-unit-${index}`,
          name: data.name.toUpperCase(),
          maxHp: hp, currentHp: hp, attack: data.stats[1].base_stat,
          imgSrc: imgSrc, scale: scale, isPlayer: isPlayer, isDead: false
        };
      }

      renderUnit(side, teamData) {
        teamData.forEach((unit) => {
          const div = document.getElementById(unit.id);
          if(div) {
            const baseTransform = `scale(${unit.scale})`;
            const flipTransform = unit.isPlayer ? `scaleX(1) ${baseTransform}` : `scaleX(1) ${baseTransform}`; 
            
            div.innerHTML = `
              <div class="mini-hud">
                <span class="hud-name">${unit.name}</span>
                <div class="hp-bg"><div class="hp-fill" id="hp-${unit.id}" style="width:100%"></div></div>
              </div>
              <div class="poke-img-wrapper">
                 <div class="shadow"></div>
                 <img src="${unit.imgSrc}" class="poke-img" id="img-${unit.id}" style="transform: ${flipTransform}" 
                      onerror="this.onerror=null; this.src='https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/other/official-artwork/${unit.name.toLowerCase().split('-')[0]}.png'; this.style.transform='${flipTransform} scale(0.6)';">
              </div>
            `;
          }
        });
      }

      calculateMaxTotalHp() {
          this.maxTotalHpPlayer = this.playerTeam.reduce((sum, p) => sum + p.maxHp, 0);
          this.maxTotalHpEnemy = this.enemyTeam.reduce((sum, p) => sum + p.maxHp, 0);
      }

      updateTotalHp() {
        const currentTotalHpPlayer = this.playerTeam.reduce((sum, p) => sum + p.currentHp, 0);
        const currentTotalHpEnemy = this.enemyTeam.reduce((sum, p) => sum + p.currentHp, 0);
        
        const playerPct = (currentTotalHpPlayer / this.maxTotalHpPlayer) * 100;
        const enemyPct = (currentTotalHpEnemy / this.maxTotalHpEnemy) * 100;

        const playerBar = document.getElementById('total-hp-player');
        const enemyBar = document.getElementById('total-hp-enemy');

        if(playerBar) {
            playerBar.style.width = `${playerPct}%`;
            playerBar.style.background = playerPct < 30 ? 'var(--hp-red)' : `linear-gradient(to right, #00f, var(--hp-green))`;
        }
        if(enemyBar) {
            enemyBar.style.width = `${enemyPct}%`;
            enemyBar.style.background = enemyPct < 30 ? 'var(--hp-red)' : `linear-gradient(to right, #ff6666, #f90)`;
        }
      }

      async battleLoop() {
        while (!this.isGameOver) {
          let allUnits = [...this.playerTeam, ...this.enemyTeam].filter(u => !u.isDead);
          if (allUnits.length === 0) break;
          allUnits.sort(() => Math.random() - 0.5);

          for (const attacker of allUnits) {
            if (this.isGameOver || attacker.isDead) continue;
            const targetTeam = attacker.isPlayer ? this.enemyTeam : this.playerTeam;
            const livingTargets = targetTeam.filter(u => !u.isDead);
            if (livingTargets.length === 0) { this.endGame(attacker.isPlayer); return; }

            const target = livingTargets[randomInt(0, livingTargets.length - 1)];
            await this.performAction(attacker, target);
            
            if (targetTeam.every(u => u.isDead)) { this.endGame(attacker.isPlayer); return; }
          }
          await wait(800);
        }
      }

      async performAction(attacker, target) {
        const skill = SKILLS[randomInt(0, SKILLS.length - 1)];
        
        let color = '#fff';
        if(skill.type === 'fire') color = '#ff3300';
        else if(skill.type === 'water') color = '#00ccff';
        else if(skill.type === 'electric') color = '#ffff00';
        else if(skill.type === 'psychic') color = '#ff00ff';
        else if(skill.type === 'earth') color = '#8d6e63';

        this.msgBox.innerHTML = `<span style="color:#ffd700">${attacker.name}</span>Ïùò <span style="color:${color}">${skill.name}</span>!`;

        const atkImg = document.getElementById(`img-${attacker.id}`);
        atkImg.classList.add('charging-aura');
        this.speedLines.style.opacity = 1; 
        await wait(400);
        atkImg.classList.remove('charging-aura');

        if (skill.mode === 'melee') await this.actionMelee(attacker, target);
        else if (skill.mode === 'beam') await this.actionBeam(attacker, target, skill.type);
        else await this.actionProjectile(attacker, target, skill.type);

        this.speedLines.style.opacity = 0;

        await this.applyDamage(attacker, target, skill.type);
      }

      async actionBeam(attacker, target, type) {
        const atkEl = document.getElementById(attacker.id);
        const tgtEl = document.getElementById(target.id);
        if(!atkEl || !tgtEl) return;

        const startRect = atkEl.getBoundingClientRect();
        const endRect = tgtEl.getBoundingClientRect();
        const startX = startRect.left + startRect.width/2;
        const startY = startRect.top + startRect.height/3;
        const dx = (endRect.left + endRect.width/2) - startX;
        const dy = (endRect.top + endRect.height/2) - startY;
        const dist = Math.sqrt(dx*dx + dy*dy);
        const angle = Math.atan2(dy, dx) * (180/Math.PI);

        const beam = document.createElement('div');
        beam.style.position = 'absolute';
        beam.style.left = startX + 'px';
        beam.style.top = startY + 'px';
        beam.style.width = '0px';
        beam.style.transformOrigin = 'left center';
        beam.style.transform = `rotate(${angle}deg)`;

        if(type === 'fire') beam.className = 'skill-beam beam-fire';
        else if(type === 'water') beam.className = 'skill-beam beam-water';
        else if(type === 'electric') beam.className = 'skill-beam beam-electric';
        else if(type === 'psychic') beam.className = 'skill-beam beam-psychic';
        else beam.className = 'skill-beam beam-fire';

        document.body.appendChild(beam);

        const shootAnim = beam.animate([
          { width: '0px' }, { width: `${dist + 50}px` }
        ], { duration: 200, fill: 'forwards', easing: 'ease-out' });

        await shootAnim.finished;

        this.stage.classList.add('camera-shake');
        this.createExplosion(tgtEl, type);
        
        const flash = document.getElementById('flash-overlay');
        flash.style.opacity = 0.8;
        setTimeout(() => flash.style.opacity = 0, 100);

        await wait(400);
        this.stage.classList.remove('camera-shake');
        beam.remove();
      }

      async actionProjectile(attacker, target, type) {
        const atkEl = document.getElementById(attacker.id);
        const tgtEl = document.getElementById(target.id);
        const startRect = atkEl.getBoundingClientRect();
        const endRect = tgtEl.getBoundingClientRect();

        const proj = document.createElement('div');
        proj.className = type === 'wind' ? 'projectile proj-wind' : 'projectile proj-earth';
        
        const startX = startRect.left + startRect.width/2;
        const startY = startRect.top + startRect.height/3;
        
        proj.style.left = startX + 'px';
        proj.style.top = startY + 'px';
        document.body.appendChild(proj);

        const targetX = endRect.left + tgtEl.offsetWidth/2;
        const targetY = endRect.top + tgtEl.offsetHeight/2;
        
        const dx = targetX - startX;
        const dy = targetY - startY;

        const anim = proj.animate([
          { transform: 'translate(0,0) scale(0.5)' },
          { transform: `translate(${dx}px, ${dy}px) scale(1.5)` }
        ], { duration: 300, easing: 'linear' });

        await anim.finished;
        proj.remove();
        this.createExplosion(tgtEl, type);
        this.stage.classList.add('camera-shake');
        setTimeout(() => this.stage.classList.remove('camera-shake'), 200);
      }

      async actionMelee(attacker, target) {
        const atkEl = document.getElementById(attacker.id);
        const tgtEl = document.getElementById(target.id);
        const startRect = atkEl.getBoundingClientRect();
        const endRect = tgtEl.getBoundingClientRect();
        
        const moveX = (endRect.left - startRect.left) + (attacker.isPlayer ? -50 : 50);
        const moveY = (endRect.top - startRect.top);
        
        const anim = atkEl.animate([
          { transform: 'translate3d(0,0,0)' },
          { transform: `translate3d(${moveX}px, ${moveY}px, 100px) scale(1.3)` }
        ], { duration: 150, easing: 'ease-in' });
        await anim.finished;

        this.stage.classList.add('camera-shake');
        this.createExplosion(tgtEl, 'physical');
        await wait(100);
        this.stage.classList.remove('camera-shake');

        const backAnim = atkEl.animate([
          { transform: `translate3d(${moveX}px, ${moveY}px, 100px)` },
          { transform: 'translate3d(0,0,0)' }
        ], { duration: 200, easing: 'ease-out' });
        await backAnim.finished;
      }

      createExplosion(targetEl, type) {
        const burst = document.createElement('div');
        burst.className = 'impact-burst';
        if(type === 'fire') burst.className += ' burst-fire';
        else if(type === 'water') burst.className += ' burst-water';
        else if(type === 'electric') burst.className += ' burst-electric';
        else if(type === 'earth') burst.className += ' burst-earth';
        else if(type === 'psychic') burst.className += ' burst-psychic';
        else burst.style.background = 'radial-gradient(circle, #fff, transparent)';
        
        targetEl.appendChild(burst);
        setTimeout(() => burst.remove(), 400);
      }

      async applyDamage(attacker, target, type) {
        const targetImg = document.getElementById(`img-${target.id}`);
        
        let hitClass = '';
        if(type === 'fire') hitClass = 'hit-fire';
        else if(type === 'water') hitClass = 'hit-water';
        else if(type === 'electric') hitClass = 'hit-electric';
        else if(type === 'earth') hitClass = 'hit-earth';
        else if(type === 'wind') hitClass = 'hit-wind';
        else if(type === 'psychic') hitClass = 'hit-psychic';

        if(hitClass) {
            targetImg.classList.add(hitClass);
            setTimeout(() => targetImg.classList.remove(hitClass), 1500);
        }

        const dmg = Math.floor(attacker.attack * 0.8 + randomInt(30, 60));
        target.currentHp = Math.max(0, target.currentHp - dmg);
        this.updateHp(target);
        this.updateTotalHp();

        await wait(500);

        if (target.currentHp <= 0) {
          target.isDead = true;
          this.msgBox.innerText = `${target.name} Îã§Ïö¥!`;
          document.getElementById(target.id).style.opacity = 0;
          await wait(1000);
          this.updateTotalHp();
        }
      }

      updateHp(unit) {
        const bar = document.getElementById(`hp-${unit.id}`);
        if(bar) {
          const pct = (unit.currentHp / unit.maxHp) * 100;
          bar.style.width = `${pct}%`;
          if(pct < 30) bar.style.background = 'var(--hp-red)';
          else if(pct < 60) bar.style.background = 'var(--hp-yellow)';
          else bar.style.background = 'var(--hp-green)';
        }
      }

      async endGame(playerWin) {
        this.isGameOver = true;
        this.msgBox.style.color = playerWin ? "#00ff00" : "#ff0000";
        this.msgBox.innerHTML = playerWin ? "üèÜ VICTORY! üèÜ" : "üíÄ GAME OVER üíÄ";
        
        await wait(4000); location.reload();
      }
    }

    const game = new AnimeBattle();
  </script>
</body>
</html>